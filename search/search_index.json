{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"git-commit-ectomy Perform a git-commit-ectomy to forever remove problematic commits from your repo history. This uses the git-forget-blob.sh script from @nachoparker . what is this This page covers how to perform a git-commit-ectomy. This is a procedure that removes problematic files or commits from your repository history. For example, suppose the intern adds and commits a 1 GB CSV file to your repository. After profusely apologizing, the intern removes the 1 GB file, but the damage is done, and the 1 GB file will forever bloat .git . Enter the git surgeon. A git surgeon can remove such problematic commits and get the commit history back in shape. Visit the Git College of Surgery on Github the procedure This surgical procedure can happen one of four ways: Git-Commit-Ectomy the Easy Way: Single Branch Complications: Dealing with Branches Transplants: Performing a Transplant with Patch Oh F&!k: Please Send Backup consult with your doctor You should consult with your doctor to determine if a git-commit-ectomy is right for your repository. This one-liner lists the 40 largest files in the repo (modify the tail line to change the number of items returned): $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1","title":"Index"},{"location":"#git-commit-ectomy","text":"Perform a git-commit-ectomy to forever remove problematic commits from your repo history. This uses the git-forget-blob.sh script from @nachoparker .","title":"git-commit-ectomy"},{"location":"#what-is-this","text":"This page covers how to perform a git-commit-ectomy. This is a procedure that removes problematic files or commits from your repository history. For example, suppose the intern adds and commits a 1 GB CSV file to your repository. After profusely apologizing, the intern removes the 1 GB file, but the damage is done, and the 1 GB file will forever bloat .git . Enter the git surgeon. A git surgeon can remove such problematic commits and get the commit history back in shape. Visit the Git College of Surgery on Github","title":"what is this"},{"location":"#the-procedure","text":"This surgical procedure can happen one of four ways: Git-Commit-Ectomy the Easy Way: Single Branch Complications: Dealing with Branches Transplants: Performing a Transplant with Patch Oh F&!k: Please Send Backup","title":"the procedure"},{"location":"#consult-with-your-doctor","text":"You should consult with your doctor to determine if a git-commit-ectomy is right for your repository. This one-liner lists the 40 largest files in the repo (modify the tail line to change the number of items returned): $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1","title":"consult with your doctor"},{"location":"branches/","text":"This page walks through a demonstration git-commit-ectomy that you can perform starting with an empty git repository. It addresses the multi-branch case . table of contents requirements consult with your doctor an ascii art crash course in surgery demo surgery: setup create initial shared commit history create multiple branches demo surgery: procedure git forget blob: cat_branch1 (branch specific history) git forget blob: cat (shared history) forget blob in one branch prepare for rebase by tagging commits perform rebase operation stitch the patient back up tips for surgery requirements Before you begin, read through the Easy Way (even if it does not apply to your case) so that you are familiar with how the process works. This page will cover a slightly more complicated git-commit-ectomy. consult with your doctor You should consult with your doctor to determine if a git-commit-ectomy is right for you. This one-liner lists the 40 largest files in the repo: git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1 an ascii art crash course in surgery Suppose our patient has a particularly painful and unnaturally large commit located in their multi-branch commit history: This is the commit to be \"ectomied\" \\/ __ o---o---(__)---o---o--------o---o---o branch A \\ \\---o---o---o branch B \\ o---o---o branch C The commit is first fixed on one of the branches, creating a new history. However, the other branches still require the old history to be retained: This commit is the last commit shared by the history of each of the branches \\/ ----o----o---o new (shared) history / \\ | -------o---o---o branch A | __ o---o----(__)----o---o old (shared) history \\ \\---o---o---o branch B \\ o---o---o branch C The second step of the procedure is to rebase branch B and branch C onto the new history. The rebase command requires three pieces of information: The source commit (where to cut) The destination commit (where to graft) The branch name (how much to cut and graft) Let us label the diagram above with the rebase source and destination commits, and use valid git branch names: ----o----o---o rebase_dest / \\ | -------o---o---o branchA | | __ o---o----(__)----o---o rebase_src \\ \\---o---o---o branchB \\ o---o---o branchC Now the commands to rebase branch B and branch C are: git rebase --onto rebase_dest rebase_src branchB git rebase --onto rebase_dest rebase_src branchC The commit history that results will look like the following: ----o----o---o / \\ | \\-----o---o---o branchA | \\ o---- \\--o---o---o branchB \\ o---o---o branchC demo surgery: setup To set up the demo surgery, we will start by creating a single branch with commits that are shared history between multiple branches. Next, we create several branches with their own commits not shared with other branches. We want to show how to remove large files from both the shared history of multiple branches, and from a single branch's history. create initial shared commit history Clone an example repo for performing surgery. You don't need a remote repository to do the demo surgery, but we will use one in our walkthrough. git clone https://github.com/charlesreid1/git-commit-ectomy-example cd git-commit-ectomy-example In this example we will create a branch called branch1 instead of using the default master branch. Start by renaming the master branch to branch1 : git branch branch1 git checkout branch1 Start with several text files, and add them to the repo history: echo \"hello foo\" > foo.txt echo \"hello bar\" > bar.txt for item in `/bin/ls -1 *.txt`; do git add ${item} && git commit ${item} -m \"adding ${item}\" done Now add several large files to the repo history: mkdir data1; mkdir data2 Now create some files in each of the two directories: cd data1/ dd if=/dev/urandom of=bat bs=1048576 count=10 dd if=/dev/urandom of=cat bs=1048576 count=10 dd if=/dev/urandom of=dat bs=1048576 count=10 cd ../ cd data2/ dd if=/dev/urandom of=fat bs=1048576 count=10 dd if=/dev/urandom of=rat bs=1048576 count=10 cd ../ This gives the following directory structure: $ tree . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2514\u2500\u2500 foo.txt Add the files to the repo in separate commits : for item in data1/bat data1/cat data1/dat data2/fat data2/rat; do git add ${item} && git commit ${item} -m \"adding ${item}\" done At this point the git log should look like this: $ git log --oneline 859fb5d (branch1) adding rat 7d104ee adding fat ddf2903 adding dat 765708d adding cat 4c9f26f adding bat 3b92007 adding bar.txt c2daf61 adding foo.txt (So far, this is identical to the single-branch setup.) create multiple branches Commit 859fb5d (where we added the file rat ) is the last commit that is shared among the history of the three branches we will create. We start by checking out a particular commit and creating each branch; this is equivalent to tagging the commit 859fb5d with three labels, branch1 , branch2 , and branch3 . Next we add different files to the different branches. Here is the directory structure we will create: Branch 1 Branch 2 Branch 3 ------------------- -------------------- ---------------------- . . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 data1 \u251c\u2500\u2500 data1 \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u251c\u2500\u2500 cat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u2502 \u2514\u2500\u2500 dat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u251c\u2500\u2500 data2 \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u251c\u2500\u2500 fat \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2502 \u2514\u2500\u2500 rat \u2502 \u2514\u2500\u2500 rat \u2502 \u2502 \u2502 \u2514\u2500\u2500 branch1_data \u2514\u2500\u2500 branch2_data \u2514\u2500\u2500 branch3_data \u251c\u2500\u2500 branch1.txt \u251c\u2500\u2500 branch2.txt \u251c\u2500\u2500 branch3.txt \u251c\u2500\u2500 bat_branch1 \u251c\u2500\u2500 bat_branch2 \u251c\u2500\u2500 bat_branch3 \u2514\u2500\u2500 cat_branch1 \u2514\u2500\u2500 cat_branch2 \u2514\u2500\u2500 cat_branch3 Here are the commands to create the branch-specific files and directories: git branch branch1; git branch branch2; git branch branch3 for BRANCH in branch1 branch2 branch3; do git checkout ${BRANCH} mkdir ${BRANCH}_data cd ${BRANCH}_data echo \"hello ${BRANCH}\" > ${BRANCH}.txt dd if=/dev/urandom of=bat_${BRANCH} bs=1048576 count=10 dd if=/dev/urandom of=cat_${BRANCH} bs=1048576 count=10 cd ../ git add ${BRANCH}_data git commit ${BRANCH}_data -m \"adding ${BRANCH}_data\" done The log should now look like the following: $ git log --oneline 2acb13d (branch3) adding branch3_data a9473c6 (branch2) adding branch2_data bfc1937 (branch1) adding branch1_data 859fb5d adding rat 7d104ee adding fat ddf2903 adding dat 765708d adding cat 4c9f26f adding bat 3b92007 adding bar.txt c2daf61 adding foo.txt Visually, the commit history looks like this: $ git lg2 * 4221760 - 2019-04-09 10:45:30 (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 10:45:28 (branch2) |/ adding branch2_data - C Reid | * f30c355 - 2019-04-09 10:45:26 (branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 | adding rat - C Reid * 7d104ee - 2019-04-09 10:34:19 | adding fat - C Reid * ddf2903 - 2019-04-09 10:34:18 | adding dat - C Reid * 765708d - 2019-04-09 10:34:18 | adding cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 | adding bat - C Reid * 3b92007 - 2019-04-09 10:33:21 | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 adding foo.txt - C Reid Or, drawing it with an ascii art tree: o adding branch3_data | | o adding branch2_data | | | | o adding branch1_data \\ | / \\ | / \\ | / \\|/ o adding rat | o adding fat | o adding dat | o adding cat | o adding bat | o adding bar.txt | o adding foo.tx | | [ ] demo surgery: procedure In this demo surgery, we will show how to remove two files: The cat_branch1 file, which was only added to branch 1 (this is essentially the equivalent procedure to the single-branch Easy Method .) The cat file, which was added in a commit that is common to multiple branches' commit histories (this is the more complicated case). git forget blob: cat_branch1 (branch specific history) We walk through how to remove a file that was only added to one branch. This procedure is basically equivalent to the Easy Method , which deals with a single branch. You are rewriting the last bit of the history of that one branch. When the old commits are changed to new commits, there will not be any other branches pointing to the old history, so things are not complicated. Start by checking out the branch: git checkout branch1 Download the git forget blob script: wget https://tinyurl.com/git-forget-blob-mac-sh -O git-forget-blob.sh chmod +x git-forget-blob.sh Check the size of the .git directory (before): $ du -hs .git 290M .git Now run the git forget blob script and pass the relative path to cat_branch1 in the repository: $ ./git-forget-blob.sh branch1_data/cat_branch1 Enumerating objects: 89, done. Counting objects: 100% (89/89), done. Delta compression using up to 4 threads. Compressing objects: 100% (81/81), done. Writing objects: 100% (89/89), done. Total 89 (delta 18), reused 0 (delta 0) Rewrite f30c3554eb89d764adb91244197dd62b58f10de2 (7/8) (1 seconds passed, remaining 0 predicted) rm 'branch1_data/cat_branch1' Ref 'refs/heads/branch1' was rewritten Enumerating objects: 43, done. Counting objects: 100% (43/43), done. Delta compression using up to 4 threads. Compressing objects: 100% (33/33), done. Writing objects: 100% (43/43), done. Total 43 (delta 7), reused 36 (delta 2) Verify that the file was removed by checking the size of the .git directory (after): $ du -hs .git 100M .git Also check the log to ensure that branch 1 has a new commit history, and that no other branches had their histories affected: $ git lg2 * 4221760 - 2019-04-09 13:45:30 -0700 (4 hours ago) (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 13:45:28 -0700 (4 hours ago) (branch2) |/ adding branch2_data - C Reid | * 70b607b - 2019-04-09 13:45:26 -0700 (4 hours ago) (HEAD -> branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/rat - C Reid * 7d104ee - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/fat - C Reid * ddf2903 - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/dat - C Reid * 765708d - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/bat - C Reid * 3b92007 - 2019-04-09 10:33:21 -0700 (7 hours ago) | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 -0700 (7 hours ago) adding foo.txt - C Reid Now that you have rewritten the history of branch1 and replaced each commit with a new one, you can replace the history of the branch on the remote by doing a force-push: git push origin master --force git forget blob: cat (shared history) Now we walk through how to forget cat , a file that was added in a commit that is shared between two or more branches. This case is more complicated, because once we rewrite the commit history of branch 1 to forget the commit where cat was added, branch 2 and branch 3 still point to the old commit history. To fix this, we graft branch 2 and branch 3 from the old commit history onto the new commit history, by picking two commits that are identical (but that have different hashes) and using those as the source and destination of our rebase operation. forget blob in one branch We start by checking on the log (this uses the same repo as resulted from rewriting branch 1 only): $ git lg2 * 4221760 - 2019-04-09 13:45:30 -0700 (4 hours ago) (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 13:45:28 -0700 (4 hours ago) (branch2) |/ adding branch2_data - C Reid | * 70b607b - 2019-04-09 13:45:26 -0700 (4 hours ago) (HEAD -> branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/rat - C Reid * 7d104ee - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/fat - C Reid * ddf2903 - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/dat - C Reid * 765708d - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/bat - C Reid * 3b92007 - 2019-04-09 10:33:21 -0700 (7 hours ago) | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 -0700 (7 hours ago) adding foo.txt - C Reid We start by removing the large file cat from one of the branches, then rebase the other branches onto the new history that is created. Here, we remove the file cat from branch 2, and rebase branches 1 and 3 onto it. Start by checking out the branch, and checking on the size of the .git folder: git checkout branch2 $ du -hs .git 100M .git Now we run the forget blob script: $ ./git-forget-blob.sh data1/cat Enumerating objects: 43, done. Counting objects: 100% (43/43), done. Delta compression using up to 4 threads. Compressing objects: 100% (28/28), done. Writing objects: 100% (43/43), done. Total 43 (delta 7), reused 43 (delta 7) Rewrite 765708d262678c2bbc15dd5b999863ad5a4dab01 (4/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite ddf2903c6d1fe41b171af7764579bc4d6a63e70f (5/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite 7d104ee90da6b3adf08f9a86d2342e3c8690dc64 (6/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite 859fb5d7db420b8aa745c50162b71c20331e90a9 (7/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite b83c9aaecf238324aa2b8a51da1ac7f69015d4d4 (8/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Ref 'refs/heads/branch2' was rewritten Enumerating objects: 51, done. Counting objects: 100% (51/51), done. Delta compression using up to 4 threads. Compressing objects: 100% (38/38), done. Writing objects: 100% (51/51), done. Total 51 (delta 9), reused 40 (delta 5) Check the size of the .git directory: $ du -hs .git 100M .git It did not change! We can see why when we check the log: $ git lg1 * 4221760 - (4 hours ago) adding branch3_data - C Reid (branch3) | * 5e2b657 - (4 hours ago) adding branch2_data - C Reid (HEAD -> branch2) | * 6ec8be5 - (7 hours ago) adding data2/rat - C Reid | * 15ec3be - (7 hours ago) adding data2/fat - C Reid | * 03a671e - (7 hours ago) adding data1/dat - C Reid | * 3cda75c - (7 hours ago) adding data1/cat - C Reid | | * 70b607b - (4 hours ago) adding branch1_data - C Reid (branch1) | |/ |/| * | 859fb5d - (7 hours ago) adding data2/rat - C Reid * | 7d104ee - (7 hours ago) adding data2/fat - C Reid * | ddf2903 - (7 hours ago) adding data1/dat - C Reid * | 765708d - (7 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (7 hours ago) adding data1/bat - C Reid * 3b92007 - (7 hours ago) adding bar.txt - C Reid * c2daf61 - (7 hours ago) adding foo.txt - C Reid branch 1 and branch 3 still refer to the old commit that added cat , so the full contents of the cat file are still in the .git directory's blobs. Now that branch 2 has a new version of the shared history, we want to rebase branch 1 and branch 3. prepare for rebase by tagging commits Start the rebase operation for the remaining branches by labeling our rebase source and destination commits. As shown in the ascii art diagrams at the top of the page, we want to find the last commit that our branches shared in common in their commit history, and mark that commit in the old history as the \"rebase source\" and mark that commit in the new history as the \"rebase destination\". In the case of our example, the commit that adds the file rat is the last commit all our branches have in common. This means that the rebase source will be the version of the \"adding rat\" commit that is in the old history (the history of branch 1 and branch 3) - commit 859fb5d . The rebase destination will be the version of the \"adding rat\" commit that is in the new history of branch 2, which corresponds to commit 6ec8be5 . Mark these two commits as the rebase_src and rebase_dest branches: git checkout 859fb5d git checkout -b rebase_src git checkout 6ec8be5 git checkout -b rebase_dest Now here is the state of the repo: $ git lg1 * 4221760 - (5 hours ago) adding branch3_data - C Reid (branch3) | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) | * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (HEAD -> rebase_dest) | * 15ec3be - (8 hours ago) adding data2/fat - C Reid | * 03a671e - (8 hours ago) adding data1/dat - C Reid | * 3cda75c - (8 hours ago) adding data1/cat - C Reid | | * 70b607b - (5 hours ago) adding branch1_data - C Reid (branch1) | |/ |/| * | 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) * | 7d104ee - (8 hours ago) adding data2/fat - C Reid * | ddf2903 - (8 hours ago) adding data1/dat - C Reid * | 765708d - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid perform rebase operation Start the rebase operation by checking out branch 2: git checkout branch2 Now rebase branch 1 from the old history onto the new history: git rebase --onto rebase_dest rebase_src branch1 You should see output like this: First, rewinding head to replay your work on top of it... Applying: adding branch1_data Verify that branch 1 and branch 2 now share a commit history: $ git lg1 * 2af1225 - (5 hours ago) adding branch1_data - C Reid (HEAD -> branch1) | * 4221760 - (5 hours ago) adding branch3_data - C Reid (branch3) | * 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) | * 7d104ee - (8 hours ago) adding data2/fat - C Reid | * ddf2903 - (8 hours ago) adding data1/dat - C Reid | * 765708d - (8 hours ago) adding data1/cat - C Reid | | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) | |/ |/| * | 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * | 15ec3be - (8 hours ago) adding data2/fat - C Reid * | 03a671e - (8 hours ago) adding data1/dat - C Reid * | 3cda75c - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Repeat the process with branch 3: git rebase --onto rebase_dest rebase_src branch3 You will see output like this: First, rewinding head to replay your work on top of it... Applying: adding branch3_data Verify that all three branches now share a commit history: $ git lg1 * b5642eb - (5 hours ago) adding branch3_data - C Reid (HEAD -> branch3) | * 2af1225 - (5 hours ago) adding branch1_data - C Reid (branch1) |/ | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) |/ * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * 15ec3be - (8 hours ago) adding data2/fat - C Reid * 03a671e - (8 hours ago) adding data1/dat - C Reid * 3cda75c - (8 hours ago) adding data1/cat - C Reid | * 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) | * 7d104ee - (8 hours ago) adding data2/fat - C Reid | * ddf2903 - (8 hours ago) adding data1/dat - C Reid | * 765708d - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Last, delete the rebase source and destination branches, so nothing points at the problematic commits or the old history: git branch -D rebase_src rebase_dest Check the log to make sure we only see the new history: $ git lg1 * b5642eb - (5 hours ago) adding branch3_data - C Reid (HEAD -> branch3) | * 2af1225 - (5 hours ago) adding branch1_data - C Reid (branch1) |/ | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) |/ * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * 15ec3be - (8 hours ago) adding data2/fat - C Reid * 03a671e - (8 hours ago) adding data1/dat - C Reid * 3cda75c - (8 hours ago) adding data1/cat - C Reid * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Congratulations, you've completed a multi-branch git-commit-ectomy! stitch the patient back up As with all surgeries, the last step is just as important as the first. All of the blobs for the old commits have been erased from the .git directory and we're ready to push the new, slimmer, rewritten history to the remote. But as before, we must do a force push, otherwise both histories will be kept. To force push: git push origin master --force tips for surgery Size up your patient before you start. Use the one-liner in the \"Consult with your Doctor\" section to size up your patient before you start. Get your patient some insurance. Back up any files you want to remove but still want to keep. Make sure you specify relative paths to file names. The git-forget-blob.sh script requires you to specify the path to the file you want to remove, relative to the top level directory of the repository . Like this: # CORRECT ./git-forget-blob.sh data/my_project/phase-1/proprietary/super_huge.file Not like this: # INCORRECT ./git-forget-blob.sh super_huge.file The long one-liner in the \"Consult with your Doctor\" section will list the largest files in the repository, with the relative path to that file (relative to the root of the repository). If you pass it a filename without a path to the file, the script will most likely complain that the file could not be found. But it may attempt to remove the file and rewrite history anyway without removing any files. If you are running git-forget-blob.sh and the size of the .git folder is not going down, it may be because you are specifying an incorrect path to the files you are trying to remove.","title":"Complications: Dealing with Branches"},{"location":"branches/#table-of-contents","text":"requirements consult with your doctor an ascii art crash course in surgery demo surgery: setup create initial shared commit history create multiple branches demo surgery: procedure git forget blob: cat_branch1 (branch specific history) git forget blob: cat (shared history) forget blob in one branch prepare for rebase by tagging commits perform rebase operation stitch the patient back up tips for surgery","title":"table of contents"},{"location":"branches/#requirements","text":"Before you begin, read through the Easy Way (even if it does not apply to your case) so that you are familiar with how the process works. This page will cover a slightly more complicated git-commit-ectomy.","title":"requirements"},{"location":"branches/#consult-with-your-doctor","text":"You should consult with your doctor to determine if a git-commit-ectomy is right for you. This one-liner lists the 40 largest files in the repo: git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1","title":"consult with your doctor"},{"location":"branches/#an-ascii-art-crash-course-in-surgery","text":"Suppose our patient has a particularly painful and unnaturally large commit located in their multi-branch commit history: This is the commit to be \"ectomied\" \\/ __ o---o---(__)---o---o--------o---o---o branch A \\ \\---o---o---o branch B \\ o---o---o branch C The commit is first fixed on one of the branches, creating a new history. However, the other branches still require the old history to be retained: This commit is the last commit shared by the history of each of the branches \\/ ----o----o---o new (shared) history / \\ | -------o---o---o branch A | __ o---o----(__)----o---o old (shared) history \\ \\---o---o---o branch B \\ o---o---o branch C The second step of the procedure is to rebase branch B and branch C onto the new history. The rebase command requires three pieces of information: The source commit (where to cut) The destination commit (where to graft) The branch name (how much to cut and graft) Let us label the diagram above with the rebase source and destination commits, and use valid git branch names: ----o----o---o rebase_dest / \\ | -------o---o---o branchA | | __ o---o----(__)----o---o rebase_src \\ \\---o---o---o branchB \\ o---o---o branchC Now the commands to rebase branch B and branch C are: git rebase --onto rebase_dest rebase_src branchB git rebase --onto rebase_dest rebase_src branchC The commit history that results will look like the following: ----o----o---o / \\ | \\-----o---o---o branchA | \\ o---- \\--o---o---o branchB \\ o---o---o branchC","title":"an ascii art crash course in surgery"},{"location":"branches/#demo-surgery-setup","text":"To set up the demo surgery, we will start by creating a single branch with commits that are shared history between multiple branches. Next, we create several branches with their own commits not shared with other branches. We want to show how to remove large files from both the shared history of multiple branches, and from a single branch's history.","title":"demo surgery: setup"},{"location":"branches/#create-initial-shared-commit-history","text":"Clone an example repo for performing surgery. You don't need a remote repository to do the demo surgery, but we will use one in our walkthrough. git clone https://github.com/charlesreid1/git-commit-ectomy-example cd git-commit-ectomy-example In this example we will create a branch called branch1 instead of using the default master branch. Start by renaming the master branch to branch1 : git branch branch1 git checkout branch1 Start with several text files, and add them to the repo history: echo \"hello foo\" > foo.txt echo \"hello bar\" > bar.txt for item in `/bin/ls -1 *.txt`; do git add ${item} && git commit ${item} -m \"adding ${item}\" done Now add several large files to the repo history: mkdir data1; mkdir data2 Now create some files in each of the two directories: cd data1/ dd if=/dev/urandom of=bat bs=1048576 count=10 dd if=/dev/urandom of=cat bs=1048576 count=10 dd if=/dev/urandom of=dat bs=1048576 count=10 cd ../ cd data2/ dd if=/dev/urandom of=fat bs=1048576 count=10 dd if=/dev/urandom of=rat bs=1048576 count=10 cd ../ This gives the following directory structure: $ tree . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2514\u2500\u2500 foo.txt Add the files to the repo in separate commits : for item in data1/bat data1/cat data1/dat data2/fat data2/rat; do git add ${item} && git commit ${item} -m \"adding ${item}\" done At this point the git log should look like this: $ git log --oneline 859fb5d (branch1) adding rat 7d104ee adding fat ddf2903 adding dat 765708d adding cat 4c9f26f adding bat 3b92007 adding bar.txt c2daf61 adding foo.txt (So far, this is identical to the single-branch setup.)","title":"create initial shared commit history"},{"location":"branches/#create-multiple-branches","text":"Commit 859fb5d (where we added the file rat ) is the last commit that is shared among the history of the three branches we will create. We start by checking out a particular commit and creating each branch; this is equivalent to tagging the commit 859fb5d with three labels, branch1 , branch2 , and branch3 . Next we add different files to the different branches. Here is the directory structure we will create: Branch 1 Branch 2 Branch 3 ------------------- -------------------- ---------------------- . . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 foo.txt \u251c\u2500\u2500 data1 \u251c\u2500\u2500 data1 \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u251c\u2500\u2500 cat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u2502 \u2514\u2500\u2500 dat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u251c\u2500\u2500 data2 \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u251c\u2500\u2500 fat \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2502 \u2514\u2500\u2500 rat \u2502 \u2514\u2500\u2500 rat \u2502 \u2502 \u2502 \u2514\u2500\u2500 branch1_data \u2514\u2500\u2500 branch2_data \u2514\u2500\u2500 branch3_data \u251c\u2500\u2500 branch1.txt \u251c\u2500\u2500 branch2.txt \u251c\u2500\u2500 branch3.txt \u251c\u2500\u2500 bat_branch1 \u251c\u2500\u2500 bat_branch2 \u251c\u2500\u2500 bat_branch3 \u2514\u2500\u2500 cat_branch1 \u2514\u2500\u2500 cat_branch2 \u2514\u2500\u2500 cat_branch3 Here are the commands to create the branch-specific files and directories: git branch branch1; git branch branch2; git branch branch3 for BRANCH in branch1 branch2 branch3; do git checkout ${BRANCH} mkdir ${BRANCH}_data cd ${BRANCH}_data echo \"hello ${BRANCH}\" > ${BRANCH}.txt dd if=/dev/urandom of=bat_${BRANCH} bs=1048576 count=10 dd if=/dev/urandom of=cat_${BRANCH} bs=1048576 count=10 cd ../ git add ${BRANCH}_data git commit ${BRANCH}_data -m \"adding ${BRANCH}_data\" done The log should now look like the following: $ git log --oneline 2acb13d (branch3) adding branch3_data a9473c6 (branch2) adding branch2_data bfc1937 (branch1) adding branch1_data 859fb5d adding rat 7d104ee adding fat ddf2903 adding dat 765708d adding cat 4c9f26f adding bat 3b92007 adding bar.txt c2daf61 adding foo.txt Visually, the commit history looks like this: $ git lg2 * 4221760 - 2019-04-09 10:45:30 (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 10:45:28 (branch2) |/ adding branch2_data - C Reid | * f30c355 - 2019-04-09 10:45:26 (branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 | adding rat - C Reid * 7d104ee - 2019-04-09 10:34:19 | adding fat - C Reid * ddf2903 - 2019-04-09 10:34:18 | adding dat - C Reid * 765708d - 2019-04-09 10:34:18 | adding cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 | adding bat - C Reid * 3b92007 - 2019-04-09 10:33:21 | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 adding foo.txt - C Reid Or, drawing it with an ascii art tree: o adding branch3_data | | o adding branch2_data | | | | o adding branch1_data \\ | / \\ | / \\ | / \\|/ o adding rat | o adding fat | o adding dat | o adding cat | o adding bat | o adding bar.txt | o adding foo.tx | | [ ]","title":"create multiple branches"},{"location":"branches/#demo-surgery-procedure","text":"In this demo surgery, we will show how to remove two files: The cat_branch1 file, which was only added to branch 1 (this is essentially the equivalent procedure to the single-branch Easy Method .) The cat file, which was added in a commit that is common to multiple branches' commit histories (this is the more complicated case).","title":"demo surgery: procedure"},{"location":"branches/#git-forget-blob-cat_branch1-branch-specific-history","text":"We walk through how to remove a file that was only added to one branch. This procedure is basically equivalent to the Easy Method , which deals with a single branch. You are rewriting the last bit of the history of that one branch. When the old commits are changed to new commits, there will not be any other branches pointing to the old history, so things are not complicated. Start by checking out the branch: git checkout branch1 Download the git forget blob script: wget https://tinyurl.com/git-forget-blob-mac-sh -O git-forget-blob.sh chmod +x git-forget-blob.sh Check the size of the .git directory (before): $ du -hs .git 290M .git Now run the git forget blob script and pass the relative path to cat_branch1 in the repository: $ ./git-forget-blob.sh branch1_data/cat_branch1 Enumerating objects: 89, done. Counting objects: 100% (89/89), done. Delta compression using up to 4 threads. Compressing objects: 100% (81/81), done. Writing objects: 100% (89/89), done. Total 89 (delta 18), reused 0 (delta 0) Rewrite f30c3554eb89d764adb91244197dd62b58f10de2 (7/8) (1 seconds passed, remaining 0 predicted) rm 'branch1_data/cat_branch1' Ref 'refs/heads/branch1' was rewritten Enumerating objects: 43, done. Counting objects: 100% (43/43), done. Delta compression using up to 4 threads. Compressing objects: 100% (33/33), done. Writing objects: 100% (43/43), done. Total 43 (delta 7), reused 36 (delta 2) Verify that the file was removed by checking the size of the .git directory (after): $ du -hs .git 100M .git Also check the log to ensure that branch 1 has a new commit history, and that no other branches had their histories affected: $ git lg2 * 4221760 - 2019-04-09 13:45:30 -0700 (4 hours ago) (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 13:45:28 -0700 (4 hours ago) (branch2) |/ adding branch2_data - C Reid | * 70b607b - 2019-04-09 13:45:26 -0700 (4 hours ago) (HEAD -> branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/rat - C Reid * 7d104ee - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/fat - C Reid * ddf2903 - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/dat - C Reid * 765708d - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/bat - C Reid * 3b92007 - 2019-04-09 10:33:21 -0700 (7 hours ago) | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 -0700 (7 hours ago) adding foo.txt - C Reid Now that you have rewritten the history of branch1 and replaced each commit with a new one, you can replace the history of the branch on the remote by doing a force-push: git push origin master --force","title":"git forget blob: cat_branch1 (branch specific history)"},{"location":"branches/#git-forget-blob-cat-shared-history","text":"Now we walk through how to forget cat , a file that was added in a commit that is shared between two or more branches. This case is more complicated, because once we rewrite the commit history of branch 1 to forget the commit where cat was added, branch 2 and branch 3 still point to the old commit history. To fix this, we graft branch 2 and branch 3 from the old commit history onto the new commit history, by picking two commits that are identical (but that have different hashes) and using those as the source and destination of our rebase operation.","title":"git forget blob: cat (shared history)"},{"location":"branches/#forget-blob-in-one-branch","text":"We start by checking on the log (this uses the same repo as resulted from rewriting branch 1 only): $ git lg2 * 4221760 - 2019-04-09 13:45:30 -0700 (4 hours ago) (branch3) | adding branch3_data - C Reid | * b83c9aa - 2019-04-09 13:45:28 -0700 (4 hours ago) (branch2) |/ adding branch2_data - C Reid | * 70b607b - 2019-04-09 13:45:26 -0700 (4 hours ago) (HEAD -> branch1) |/ adding branch1_data - C Reid * 859fb5d - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/rat - C Reid * 7d104ee - 2019-04-09 10:34:19 -0700 (7 hours ago) | adding data2/fat - C Reid * ddf2903 - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/dat - C Reid * 765708d - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/cat - C Reid * 4c9f26f - 2019-04-09 10:34:18 -0700 (7 hours ago) | adding data1/bat - C Reid * 3b92007 - 2019-04-09 10:33:21 -0700 (7 hours ago) | adding bar.txt - C Reid * c2daf61 - 2019-04-09 10:33:14 -0700 (7 hours ago) adding foo.txt - C Reid We start by removing the large file cat from one of the branches, then rebase the other branches onto the new history that is created. Here, we remove the file cat from branch 2, and rebase branches 1 and 3 onto it. Start by checking out the branch, and checking on the size of the .git folder: git checkout branch2 $ du -hs .git 100M .git Now we run the forget blob script: $ ./git-forget-blob.sh data1/cat Enumerating objects: 43, done. Counting objects: 100% (43/43), done. Delta compression using up to 4 threads. Compressing objects: 100% (28/28), done. Writing objects: 100% (43/43), done. Total 43 (delta 7), reused 43 (delta 7) Rewrite 765708d262678c2bbc15dd5b999863ad5a4dab01 (4/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite ddf2903c6d1fe41b171af7764579bc4d6a63e70f (5/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite 7d104ee90da6b3adf08f9a86d2342e3c8690dc64 (6/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite 859fb5d7db420b8aa745c50162b71c20331e90a9 (7/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Rewrite b83c9aaecf238324aa2b8a51da1ac7f69015d4d4 (8/8) (0 seconds passed, remaining 0 predicted) rm 'data1/cat' Ref 'refs/heads/branch2' was rewritten Enumerating objects: 51, done. Counting objects: 100% (51/51), done. Delta compression using up to 4 threads. Compressing objects: 100% (38/38), done. Writing objects: 100% (51/51), done. Total 51 (delta 9), reused 40 (delta 5) Check the size of the .git directory: $ du -hs .git 100M .git It did not change! We can see why when we check the log: $ git lg1 * 4221760 - (4 hours ago) adding branch3_data - C Reid (branch3) | * 5e2b657 - (4 hours ago) adding branch2_data - C Reid (HEAD -> branch2) | * 6ec8be5 - (7 hours ago) adding data2/rat - C Reid | * 15ec3be - (7 hours ago) adding data2/fat - C Reid | * 03a671e - (7 hours ago) adding data1/dat - C Reid | * 3cda75c - (7 hours ago) adding data1/cat - C Reid | | * 70b607b - (4 hours ago) adding branch1_data - C Reid (branch1) | |/ |/| * | 859fb5d - (7 hours ago) adding data2/rat - C Reid * | 7d104ee - (7 hours ago) adding data2/fat - C Reid * | ddf2903 - (7 hours ago) adding data1/dat - C Reid * | 765708d - (7 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (7 hours ago) adding data1/bat - C Reid * 3b92007 - (7 hours ago) adding bar.txt - C Reid * c2daf61 - (7 hours ago) adding foo.txt - C Reid branch 1 and branch 3 still refer to the old commit that added cat , so the full contents of the cat file are still in the .git directory's blobs. Now that branch 2 has a new version of the shared history, we want to rebase branch 1 and branch 3.","title":"forget blob in one branch"},{"location":"branches/#prepare-for-rebase-by-tagging-commits","text":"Start the rebase operation for the remaining branches by labeling our rebase source and destination commits. As shown in the ascii art diagrams at the top of the page, we want to find the last commit that our branches shared in common in their commit history, and mark that commit in the old history as the \"rebase source\" and mark that commit in the new history as the \"rebase destination\". In the case of our example, the commit that adds the file rat is the last commit all our branches have in common. This means that the rebase source will be the version of the \"adding rat\" commit that is in the old history (the history of branch 1 and branch 3) - commit 859fb5d . The rebase destination will be the version of the \"adding rat\" commit that is in the new history of branch 2, which corresponds to commit 6ec8be5 . Mark these two commits as the rebase_src and rebase_dest branches: git checkout 859fb5d git checkout -b rebase_src git checkout 6ec8be5 git checkout -b rebase_dest Now here is the state of the repo: $ git lg1 * 4221760 - (5 hours ago) adding branch3_data - C Reid (branch3) | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) | * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (HEAD -> rebase_dest) | * 15ec3be - (8 hours ago) adding data2/fat - C Reid | * 03a671e - (8 hours ago) adding data1/dat - C Reid | * 3cda75c - (8 hours ago) adding data1/cat - C Reid | | * 70b607b - (5 hours ago) adding branch1_data - C Reid (branch1) | |/ |/| * | 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) * | 7d104ee - (8 hours ago) adding data2/fat - C Reid * | ddf2903 - (8 hours ago) adding data1/dat - C Reid * | 765708d - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid","title":"prepare for rebase by tagging commits"},{"location":"branches/#perform-rebase-operation","text":"Start the rebase operation by checking out branch 2: git checkout branch2 Now rebase branch 1 from the old history onto the new history: git rebase --onto rebase_dest rebase_src branch1 You should see output like this: First, rewinding head to replay your work on top of it... Applying: adding branch1_data Verify that branch 1 and branch 2 now share a commit history: $ git lg1 * 2af1225 - (5 hours ago) adding branch1_data - C Reid (HEAD -> branch1) | * 4221760 - (5 hours ago) adding branch3_data - C Reid (branch3) | * 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) | * 7d104ee - (8 hours ago) adding data2/fat - C Reid | * ddf2903 - (8 hours ago) adding data1/dat - C Reid | * 765708d - (8 hours ago) adding data1/cat - C Reid | | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) | |/ |/| * | 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * | 15ec3be - (8 hours ago) adding data2/fat - C Reid * | 03a671e - (8 hours ago) adding data1/dat - C Reid * | 3cda75c - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Repeat the process with branch 3: git rebase --onto rebase_dest rebase_src branch3 You will see output like this: First, rewinding head to replay your work on top of it... Applying: adding branch3_data Verify that all three branches now share a commit history: $ git lg1 * b5642eb - (5 hours ago) adding branch3_data - C Reid (HEAD -> branch3) | * 2af1225 - (5 hours ago) adding branch1_data - C Reid (branch1) |/ | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) |/ * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * 15ec3be - (8 hours ago) adding data2/fat - C Reid * 03a671e - (8 hours ago) adding data1/dat - C Reid * 3cda75c - (8 hours ago) adding data1/cat - C Reid | * 859fb5d - (8 hours ago) adding data2/rat - C Reid (rebase_src) | * 7d104ee - (8 hours ago) adding data2/fat - C Reid | * ddf2903 - (8 hours ago) adding data1/dat - C Reid | * 765708d - (8 hours ago) adding data1/cat - C Reid |/ * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Last, delete the rebase source and destination branches, so nothing points at the problematic commits or the old history: git branch -D rebase_src rebase_dest Check the log to make sure we only see the new history: $ git lg1 * b5642eb - (5 hours ago) adding branch3_data - C Reid (HEAD -> branch3) | * 2af1225 - (5 hours ago) adding branch1_data - C Reid (branch1) |/ | * 5e2b657 - (5 hours ago) adding branch2_data - C Reid (branch2) |/ * 6ec8be5 - (8 hours ago) adding data2/rat - C Reid (rebase_dest) * 15ec3be - (8 hours ago) adding data2/fat - C Reid * 03a671e - (8 hours ago) adding data1/dat - C Reid * 3cda75c - (8 hours ago) adding data1/cat - C Reid * 4c9f26f - (8 hours ago) adding data1/bat - C Reid * 3b92007 - (8 hours ago) adding bar.txt - C Reid * c2daf61 - (8 hours ago) adding foo.txt - C Reid Congratulations, you've completed a multi-branch git-commit-ectomy!","title":"perform rebase operation"},{"location":"branches/#stitch-the-patient-back-up","text":"As with all surgeries, the last step is just as important as the first. All of the blobs for the old commits have been erased from the .git directory and we're ready to push the new, slimmer, rewritten history to the remote. But as before, we must do a force push, otherwise both histories will be kept. To force push: git push origin master --force","title":"stitch the patient back up"},{"location":"branches/#tips-for-surgery","text":"Size up your patient before you start. Use the one-liner in the \"Consult with your Doctor\" section to size up your patient before you start. Get your patient some insurance. Back up any files you want to remove but still want to keep. Make sure you specify relative paths to file names. The git-forget-blob.sh script requires you to specify the path to the file you want to remove, relative to the top level directory of the repository . Like this: # CORRECT ./git-forget-blob.sh data/my_project/phase-1/proprietary/super_huge.file Not like this: # INCORRECT ./git-forget-blob.sh super_huge.file The long one-liner in the \"Consult with your Doctor\" section will list the largest files in the repository, with the relative path to that file (relative to the root of the repository). If you pass it a filename without a path to the file, the script will most likely complain that the file could not be found. But it may attempt to remove the file and rewrite history anyway without removing any files. If you are running git-forget-blob.sh and the size of the .git folder is not going down, it may be because you are specifying an incorrect path to the files you are trying to remove.","title":"tips for surgery"},{"location":"easy/","text":"This page walks through a demonstration git-commit-ectomy that you can perform starting with an empty git repository. It addresses the single-branch case . table of contents requirements consult with your doctor an ascii art crash course in surgery demo surgery: setup side note: how to make a fat file make some text files make some fat files commit files demo surgery: procedure prepare tools the command that doesn't work: git rm the command that does work: git forget blob how it worked stitch the patient back up tips for surgery requirements This guide utilizes GNU xargs. You should run it on Linux, or use Homebrew's gxargs if on a Mac. consult with your doctor You should consult with your doctor to determine if a git-commit-ectomy is right for you. This one-liner lists the 40 largest files in the repo (modify the tail line to change the number): $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1 When you're ready to perform the surgery, append a cut command to get the relative path to the file only , without listing the size of the file, which is what we will need when we carry out the git-commit-ectomy: $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1 | \\ cut -f 2 -d' ' an ascii art crash course in surgery Suppose our patient has a particularly painful and unnaturally large commit located in their commit history: This is the commit to be \"ectomied\" \\/ __ o---o---(__)---o---o--o The git commit ectomy will rewrite the history without the problematic commit: __ o---o---(__)---o---o---o old history \\ \\---o----o---o---o new history /\\ The problematic commit is modified to be smaller in the new history If there is only one branch, no branches or tags or labels will refer to the old history, so the commits are not kept in the .git directory. Finally, running a git push <remote-name> <branch-name> --force will force the old history to be replaced with the new history on the remote. Here is the final commit history: o---o \\ \\---o----o---o---o new history demo surgery: setup Clone an example repo for performing surgery. You don't need a remote repository to do the demo surgery, but we will use one in our walkthrough. $ git clone https://github.com/charlesreid1/git-commit-ectomy-example side note: how to make a fat file We will use the dd command to create files with a specified number of bits. For example, to create a 10 MB file, we can issue the command: $ dd if=/dev/urandom of=my_big_fat_file bs=1048576 count=10 Important: You must use /dev/urandom with a non-zero block size. If you use /dev/zeros then each file will be identical and git will not store them separately. Then your surgery will go very badly. Note: 1048576 = 2^20 bytes comes from the fact that 1 KB = 2^10 bytes, and 1 MB = 2^10 KB, for a total of 2^20 bytes per megabyte. count=10 means we make 10 blocks, each of size 1 MB (1048576 bytes). make some text files We start by adding some small boring text files to the repository: $ echo \"hello foo\" > foo.txt; echo \"hello bar\" > bar.txt Now add them to the repo history: $ for item in `/bin/ls -1 *.txt`; do git add ${item} && git commit ${item} -m \"adding ${item}\" done make some fat files To demonstrate the importance of specifying the path to the large files being removed from the repository, we add several 10 MB files inside of a subdirectory. Start with the directory structure: $ mkdir data1; mkdir data2 Now create some files in each of the two directories: $ cd data1/ dd if=/dev/urandom of=bat bs=1048576 count=10 dd if=/dev/urandom of=cat bs=1048576 count=10 dd if=/dev/urandom of=dat bs=1048576 count=10 cd ../ cd data2/ dd if=/dev/urandom of=fat bs=1048576 count=10 dd if=/dev/urandom of=rat bs=1048576 count=10 cd ../ Now we have the following directory structure: $ tree . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2514\u2500\u2500 foo.txt $ ls -lhg data1 -rw-r--r-- 1 staff 10M Apr 10 18:30 bat -rw-r--r-- 1 staff 10M Apr 10 18:30 cat -rw-r--r-- 1 staff 10M Apr 10 18:30 dat $ ls -lhg data2 -rw-r--r-- 1 staff 10M Apr 10 18:30 fat -rw-r--r-- 1 staff 10M Apr 10 18:30 rat Also make sure they are unique (hence /dev/random and not /dev/zero ): $ for i in `/bin/ls -1 data1/*at data2/*at`; do md5 ${i} done MD5 (bat) = 140c7d1e5a12c0eb2fefd5529250a280 MD5 (cat) = 9345ca4033c7e42fb009e3b8014570dc MD5 (dat) = fadc3114fe9a70f688eba0db4e0dc7a9 MD5 (fat) = 39e98200043e438f9070369989b2d964 MD5 (rat) = 77b1c3077041078fd1f371b1bb7dd6e4 commit files Add the files to the repo in separate commits : $ for item in data1/bat data1/cat data1/dat data2/fat data2/rat; do git add ${item} && git commit ${item} -m \"adding ${item}\" done Now push all the commits to the remote (this will take a while): $ git push origin master Now you should see everything in the commit history on Github: You should also see it locally in the git log: $ git log --oneline 902b0d8 adding rat b3376bd adding fat e2427de adding dat 25682b5 addding cat 495235a addding bat 2506d38 adding bar.txt 2eb8d13 adding foo.txt demo surgery: procedure prepare tools Use git-forget-blob.sh to forget the blob. Start by downloading it: $ wget https://tinyurl.com/git-forget-blob-mac-sh -O git-forget-blob.sh chmod +x git-forget-blob.sh This script will detect if you are on a Mac, and if so, will use the GNU gxargs instead of the BSD xargs . This requires GNU tools to be installed via Homebrew: $ brew install gnu-xargs When installing gnu-xargs , you can also add the --with-default-names flag to brew to overwrite the default BSD version of xargs (which is not compatible with the GNU version of xargs). $ brew install gnu-xargs --with-default-names To use the git-forget-blob.sh script: $ ./git-forget-blob.sh <relative-path-to-file> (See below for more detail.) the command that doesn't work: git rm Start by checking the size of the repo: $ du -hs .git 50M .git Now remove dat using git rm : $ git rm dat git commit dat -m 'Removing dat' git push origin master This, of course, does not change the size of the repo. If we clone a fresh copy from Github, the size of the repo is still the same: $ du -hs .git 50M .git Why? Because git is cursed with perfect memory, and will not forget a large file that's been added to the repo. the command that does work: git forget blob To force git to forget a large file that's been added to the repo, use the git-forget-blob.sh script to permanently remove it. Here, we remove the dat file from the repo history by modifying all commits that involve the dat file, and rewriting those commits (and, by consequence, all commits that happened after that commit). Here is how to permanently remove dat from the repo history and rewrite all commits (we specify data1/bat and not bat ): $ ./git-forget-blob.sh data1/bat Enumerating objects: 26, done. Counting objects: 100% (26/26), done. Delta compression using up to 4 threads. Compressing objects: 100% (20/20), done. Writing objects: 100% (26/26), done. Total 26 (delta 1), reused 26 (delta 1) Rewrite 495235a86e70be03ee0749733645615a093b547a (3/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite 25682b53e6c8c88328346fc2e245b5946adec6cb (4/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite e2427def6f9de095928aaecfd9fef892880e6ce8 (5/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite b3376bdc847e26bdb323408afa06112dd4c2b36d (6/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite 902b0d8e46ec8d1487ae3db3b2989dfade5dacbe (7/7) (1 seconds passed, remaining 0 predicted) rm 'data1/bat' Ref 'refs/heads/master' was rewritten Enumerating objects: 23, done. Counting objects: 100% (23/23), done. Delta compression using up to 4 threads. Compressing objects: 100% (18/18), done. Writing objects: 100% (23/23), done. Total 23 (delta 1), reused 12 (delta 0) Verify it worked by finding size of .git directory $ du -hs .git 40M .git Success! Note that if you mistakenly specify the name of the file only, without the relative path to the file, git will be looking for the file at the top level of the repository, and the file will not be found: $ ./git-forget-blob.sh bat Enumerating objects: 26, done. Counting objects: 100% (26/26), done. Delta compression using up to 4 threads. Compressing objects: 100% (21/21), done. Writing objects: 100% (26/26), done. Total 26 (delta 1), reused 0 (delta 0) bat not found in repo history how it worked If we check the git log we can see what happened - all commits involving bat were rewritten. It's important to note that when git computes the hash of each commit, it includes the hash of the prior commit - meaning, if one commit in a repository's history changes, every commit in a repository's history changes. Thus, we will rewrite every single commit since the very first commit that introduced the file we removed . Compare the old and new logs: # NEW LOG # OLD LOG $ git log --oneline $ git log --oneline 5bc57f6 adding rat 902b0d8 adding rat 3153621 adding fat b3376bd adding fat c456173 adding dat e2427de adding dat 078a5be addding cat 25682b5 addding cat 3cd75ce addding bat 495235a addding bat 2506d38 adding bar.txt 2506d38 adding bar.txt 2eb8d13 adding foo.txt 2eb8d13 adding foo.txt Note that the first two commits, which did not involve the bat file, remain identical, but every commit after 495235a (which first introduced bat) is changed. Each commit hash is computed using the prior commit hash, so once commit 495235a changes, it cascades through the entire history by changing all subsequent commit hashes. stitch the patient back up Of course, for surgeons, as for airline pilots, if the last step is screwed up, nothing else counts. We asked git to forget a file, which it did, but that required modifying git's entire commit history. At this point we have two parallel master branches - the old history and the new history. If we simply git push our branch to the Github remote, we will have a huge headache: both histories will end up on Github, our git history will contain duplicates of every commit, and the old and new history will show up side by side. To do this correctly , we need to use the force when we push, which tells the Github remote to rewrite whatever commit history it currently has with the commit history that we are pushing. git push origin master --force This will ensure that Github does not keep duplicate copies of all commits. Here is a screenshot of the repo on github before we ran git-forget-blob : And a screenshot of the repo after: tips for surgery Size up your patient before you start. Use the one-liner in the \"Consult with your Doctor\" section to size up your patient before you start (modify the tail line to change the number of files). Get your patient some insurance. Back up any files you want to remove but still want to keep. Make sure you specify relative paths to file names. The git-forget-blob.sh script requires you to specify the path to the file you want to remove, relative to the top level directory of the repository . Like this: # CORRECT ./git-forget-blob.sh data/my_project/phase-1/proprietary/super_huge.file Not like this: # INCORRECT ./git-forget-blob.sh super_huge.file The long one-liner in the \"Consult with your Doctor\" section will list the largest files in the repository, with the relative path to that file (relative to the root of the repository). If you pass it a filename without a path to the file, the script will most likely complain that the file could not be found. But it may attempt to remove the file and rewrite history anyway without removing any files. If you are running git-forget-blob.sh and the size of the .git folder is not going down, it may be because you are specifying an incorrect path to the files you are trying to remove.","title":"Git-Commit-Ectomy the Easy Way: Single Branch"},{"location":"easy/#table-of-contents","text":"requirements consult with your doctor an ascii art crash course in surgery demo surgery: setup side note: how to make a fat file make some text files make some fat files commit files demo surgery: procedure prepare tools the command that doesn't work: git rm the command that does work: git forget blob how it worked stitch the patient back up tips for surgery","title":"table of contents"},{"location":"easy/#requirements","text":"This guide utilizes GNU xargs. You should run it on Linux, or use Homebrew's gxargs if on a Mac.","title":"requirements"},{"location":"easy/#consult-with-your-doctor","text":"You should consult with your doctor to determine if a git-commit-ectomy is right for you. This one-liner lists the 40 largest files in the repo (modify the tail line to change the number): $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1 When you're ready to perform the surgery, append a cut command to get the relative path to the file only , without listing the size of the file, which is what we will need when we carry out the git-commit-ectomy: $ git rev-list --all --objects | \\ sed -n $(git rev-list --objects --all | \\ cut -f1 -d' ' | \\ git cat-file --batch-check | \\ grep blob | \\ sort -n -k 3 | \\ \\ tail -n40 | \\ \\ while read hash type size; do echo -n \"-e s/$hash/$size/p \"; done) | \\ sort -n -r -k1 | \\ cut -f 2 -d' '","title":"consult with your doctor"},{"location":"easy/#an-ascii-art-crash-course-in-surgery","text":"Suppose our patient has a particularly painful and unnaturally large commit located in their commit history: This is the commit to be \"ectomied\" \\/ __ o---o---(__)---o---o--o The git commit ectomy will rewrite the history without the problematic commit: __ o---o---(__)---o---o---o old history \\ \\---o----o---o---o new history /\\ The problematic commit is modified to be smaller in the new history If there is only one branch, no branches or tags or labels will refer to the old history, so the commits are not kept in the .git directory. Finally, running a git push <remote-name> <branch-name> --force will force the old history to be replaced with the new history on the remote. Here is the final commit history: o---o \\ \\---o----o---o---o new history","title":"an ascii art crash course in surgery"},{"location":"easy/#demo-surgery-setup","text":"Clone an example repo for performing surgery. You don't need a remote repository to do the demo surgery, but we will use one in our walkthrough. $ git clone https://github.com/charlesreid1/git-commit-ectomy-example","title":"demo surgery: setup"},{"location":"easy/#side-note-how-to-make-a-fat-file","text":"We will use the dd command to create files with a specified number of bits. For example, to create a 10 MB file, we can issue the command: $ dd if=/dev/urandom of=my_big_fat_file bs=1048576 count=10 Important: You must use /dev/urandom with a non-zero block size. If you use /dev/zeros then each file will be identical and git will not store them separately. Then your surgery will go very badly. Note: 1048576 = 2^20 bytes comes from the fact that 1 KB = 2^10 bytes, and 1 MB = 2^10 KB, for a total of 2^20 bytes per megabyte. count=10 means we make 10 blocks, each of size 1 MB (1048576 bytes).","title":"side note: how to make a fat file"},{"location":"easy/#make-some-text-files","text":"We start by adding some small boring text files to the repository: $ echo \"hello foo\" > foo.txt; echo \"hello bar\" > bar.txt Now add them to the repo history: $ for item in `/bin/ls -1 *.txt`; do git add ${item} && git commit ${item} -m \"adding ${item}\" done","title":"make some text files"},{"location":"easy/#make-some-fat-files","text":"To demonstrate the importance of specifying the path to the large files being removed from the repository, we add several 10 MB files inside of a subdirectory. Start with the directory structure: $ mkdir data1; mkdir data2 Now create some files in each of the two directories: $ cd data1/ dd if=/dev/urandom of=bat bs=1048576 count=10 dd if=/dev/urandom of=cat bs=1048576 count=10 dd if=/dev/urandom of=dat bs=1048576 count=10 cd ../ cd data2/ dd if=/dev/urandom of=fat bs=1048576 count=10 dd if=/dev/urandom of=rat bs=1048576 count=10 cd ../ Now we have the following directory structure: $ tree . . \u251c\u2500\u2500 bar.txt \u251c\u2500\u2500 data1 \u2502 \u251c\u2500\u2500 bat \u2502 \u251c\u2500\u2500 cat \u2502 \u2514\u2500\u2500 dat \u251c\u2500\u2500 data2 \u2502 \u251c\u2500\u2500 fat \u2502 \u2514\u2500\u2500 rat \u2514\u2500\u2500 foo.txt $ ls -lhg data1 -rw-r--r-- 1 staff 10M Apr 10 18:30 bat -rw-r--r-- 1 staff 10M Apr 10 18:30 cat -rw-r--r-- 1 staff 10M Apr 10 18:30 dat $ ls -lhg data2 -rw-r--r-- 1 staff 10M Apr 10 18:30 fat -rw-r--r-- 1 staff 10M Apr 10 18:30 rat Also make sure they are unique (hence /dev/random and not /dev/zero ): $ for i in `/bin/ls -1 data1/*at data2/*at`; do md5 ${i} done MD5 (bat) = 140c7d1e5a12c0eb2fefd5529250a280 MD5 (cat) = 9345ca4033c7e42fb009e3b8014570dc MD5 (dat) = fadc3114fe9a70f688eba0db4e0dc7a9 MD5 (fat) = 39e98200043e438f9070369989b2d964 MD5 (rat) = 77b1c3077041078fd1f371b1bb7dd6e4","title":"make some fat files"},{"location":"easy/#commit-files","text":"Add the files to the repo in separate commits : $ for item in data1/bat data1/cat data1/dat data2/fat data2/rat; do git add ${item} && git commit ${item} -m \"adding ${item}\" done Now push all the commits to the remote (this will take a while): $ git push origin master Now you should see everything in the commit history on Github: You should also see it locally in the git log: $ git log --oneline 902b0d8 adding rat b3376bd adding fat e2427de adding dat 25682b5 addding cat 495235a addding bat 2506d38 adding bar.txt 2eb8d13 adding foo.txt","title":"commit files"},{"location":"easy/#demo-surgery-procedure","text":"","title":"demo surgery: procedure"},{"location":"easy/#prepare-tools","text":"Use git-forget-blob.sh to forget the blob. Start by downloading it: $ wget https://tinyurl.com/git-forget-blob-mac-sh -O git-forget-blob.sh chmod +x git-forget-blob.sh This script will detect if you are on a Mac, and if so, will use the GNU gxargs instead of the BSD xargs . This requires GNU tools to be installed via Homebrew: $ brew install gnu-xargs When installing gnu-xargs , you can also add the --with-default-names flag to brew to overwrite the default BSD version of xargs (which is not compatible with the GNU version of xargs). $ brew install gnu-xargs --with-default-names To use the git-forget-blob.sh script: $ ./git-forget-blob.sh <relative-path-to-file> (See below for more detail.)","title":"prepare tools"},{"location":"easy/#the-command-that-doesnt-work-git-rm","text":"Start by checking the size of the repo: $ du -hs .git 50M .git Now remove dat using git rm : $ git rm dat git commit dat -m 'Removing dat' git push origin master This, of course, does not change the size of the repo. If we clone a fresh copy from Github, the size of the repo is still the same: $ du -hs .git 50M .git Why? Because git is cursed with perfect memory, and will not forget a large file that's been added to the repo.","title":"the command that doesn't work: git rm"},{"location":"easy/#the-command-that-does-work-git-forget-blob","text":"To force git to forget a large file that's been added to the repo, use the git-forget-blob.sh script to permanently remove it. Here, we remove the dat file from the repo history by modifying all commits that involve the dat file, and rewriting those commits (and, by consequence, all commits that happened after that commit). Here is how to permanently remove dat from the repo history and rewrite all commits (we specify data1/bat and not bat ): $ ./git-forget-blob.sh data1/bat Enumerating objects: 26, done. Counting objects: 100% (26/26), done. Delta compression using up to 4 threads. Compressing objects: 100% (20/20), done. Writing objects: 100% (26/26), done. Total 26 (delta 1), reused 26 (delta 1) Rewrite 495235a86e70be03ee0749733645615a093b547a (3/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite 25682b53e6c8c88328346fc2e245b5946adec6cb (4/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite e2427def6f9de095928aaecfd9fef892880e6ce8 (5/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite b3376bdc847e26bdb323408afa06112dd4c2b36d (6/7) (0 seconds passed, remaining 0 predicted) rm 'data1/bat' Rewrite 902b0d8e46ec8d1487ae3db3b2989dfade5dacbe (7/7) (1 seconds passed, remaining 0 predicted) rm 'data1/bat' Ref 'refs/heads/master' was rewritten Enumerating objects: 23, done. Counting objects: 100% (23/23), done. Delta compression using up to 4 threads. Compressing objects: 100% (18/18), done. Writing objects: 100% (23/23), done. Total 23 (delta 1), reused 12 (delta 0) Verify it worked by finding size of .git directory $ du -hs .git 40M .git Success! Note that if you mistakenly specify the name of the file only, without the relative path to the file, git will be looking for the file at the top level of the repository, and the file will not be found: $ ./git-forget-blob.sh bat Enumerating objects: 26, done. Counting objects: 100% (26/26), done. Delta compression using up to 4 threads. Compressing objects: 100% (21/21), done. Writing objects: 100% (26/26), done. Total 26 (delta 1), reused 0 (delta 0) bat not found in repo history","title":"the command that does work: git forget blob"},{"location":"easy/#how-it-worked","text":"If we check the git log we can see what happened - all commits involving bat were rewritten. It's important to note that when git computes the hash of each commit, it includes the hash of the prior commit - meaning, if one commit in a repository's history changes, every commit in a repository's history changes. Thus, we will rewrite every single commit since the very first commit that introduced the file we removed . Compare the old and new logs: # NEW LOG # OLD LOG $ git log --oneline $ git log --oneline 5bc57f6 adding rat 902b0d8 adding rat 3153621 adding fat b3376bd adding fat c456173 adding dat e2427de adding dat 078a5be addding cat 25682b5 addding cat 3cd75ce addding bat 495235a addding bat 2506d38 adding bar.txt 2506d38 adding bar.txt 2eb8d13 adding foo.txt 2eb8d13 adding foo.txt Note that the first two commits, which did not involve the bat file, remain identical, but every commit after 495235a (which first introduced bat) is changed. Each commit hash is computed using the prior commit hash, so once commit 495235a changes, it cascades through the entire history by changing all subsequent commit hashes.","title":"how it worked"},{"location":"easy/#stitch-the-patient-back-up","text":"Of course, for surgeons, as for airline pilots, if the last step is screwed up, nothing else counts. We asked git to forget a file, which it did, but that required modifying git's entire commit history. At this point we have two parallel master branches - the old history and the new history. If we simply git push our branch to the Github remote, we will have a huge headache: both histories will end up on Github, our git history will contain duplicates of every commit, and the old and new history will show up side by side. To do this correctly , we need to use the force when we push, which tells the Github remote to rewrite whatever commit history it currently has with the commit history that we are pushing. git push origin master --force This will ensure that Github does not keep duplicate copies of all commits. Here is a screenshot of the repo on github before we ran git-forget-blob : And a screenshot of the repo after:","title":"stitch the patient back up"},{"location":"easy/#tips-for-surgery","text":"Size up your patient before you start. Use the one-liner in the \"Consult with your Doctor\" section to size up your patient before you start (modify the tail line to change the number of files). Get your patient some insurance. Back up any files you want to remove but still want to keep. Make sure you specify relative paths to file names. The git-forget-blob.sh script requires you to specify the path to the file you want to remove, relative to the top level directory of the repository . Like this: # CORRECT ./git-forget-blob.sh data/my_project/phase-1/proprietary/super_huge.file Not like this: # INCORRECT ./git-forget-blob.sh super_huge.file The long one-liner in the \"Consult with your Doctor\" section will list the largest files in the repository, with the relative path to that file (relative to the root of the repository). If you pass it a filename without a path to the file, the script will most likely complain that the file could not be found. But it may attempt to remove the file and rewrite history anyway without removing any files. If you are running git-forget-blob.sh and the size of the .git folder is not going down, it may be because you are specifying an incorrect path to the files you are trying to remove.","title":"tips for surgery"},{"location":"ohfk/","text":"Oh F&!k: Please Send Backup When you use the single-branch procedure instead of the multi-branch procedure... bad things happen. Possible complications to all of this include: Users who did not get the memo about the entire history of the repository being rewritten, who did not listen when they were told to clone a fresh copy, and who pushed directly to master even though they were told repeatedly not to, so then you end up with the entire old history being pushed to the remote. (Deal with this proactively by protecting the master branch!) Accidentally carrying out the procedure multiple times, resulting in 2, 3, 4, even 5 copies of each commit, and the duplicate commits simply refuse to die; A confusing, tangled, messy commit history that is completely uninterpretable the first case: users pushing old history When the git-commit-ectomy is complete, it is recommended that you turn on branch protection right away. But in case you did not, and a user pushed the old history to the remote, here is how to deal. From a copy of the repository with only the new history (this is going to be the copy of the repository that is on the surgeon's computer, preferrably the repo in which the git-commit-etomy was originally performed), run the command git push origin master --force (where origin is the remote with the duplicate history, and master is the name of the branch you're pushing. Replace these with whatever remote/branch names you are using.) Turn on branch protection immediately afterwards. If you do not have a copy of the repository with only the new history (i.e., if you removed the copy of the repository in which the git-commit-ectomy was performed), you can still separate the old and new histories. However, you must have a copy of the old git log and/or the new git log, so that you have some way of knowing which commits belong to which history. If you have this info, continue on to \"the second case.\" the second case: scrubbling multiple attempts If you have performed a git-commit-ectomy multiple times, and the duplicate commits are simply piling up and will not go away, you will need to use either a git rebase or a git cherry pick operation. Find the branch that you want to keep, and the commit at which to start the new branch with the new history. Then rebase or cherry pick any missing commits onto it. Finally, remove all other branches on the remote. Example: Suppose we are trying to fix the history of the master branch, which is a mess, by creating a new branch new_master that has an improved and cleaned-up version of the master branch history. We start by checking out the particular commit where we wish new_master to diverge from master : git checkout <hash-of-commit-to-split-at> # starting point for new branch git branch new_master # create new branch git checkout new_master # switch to new branch Next, we modify the repository by making commits, doing git rebase and git cherry pick operations, and creating a new branch with a long and totally separate commit history from master. ...make some commits... ...rebase some stuff... ...cherry pick some stuff... ...now new branch has a long and totally different commit history from master... Finally, when the new_master branch is ready, push it to the remote (e.g., origin ): git push origin new_master # push all the new stuff to remote \"origin\" The last step is to delete all other branches except for the new_master branch, so that we don't preserve the messy history of the master branch. (The whole point of the new_master branch was to clean it up.) Deleting the master branch on the remote is a two step operation: first, delete the branch locally, then push the deleted \"ghost branch\" to the remote (which will propagate the deletion of the branch): git branch -D master # delete git branch master locally git push origin :master # propagate deletion of branch \"master\" to remote \"origin\" Note the syntax for deleting a branch is: git push <name-of-remote> :<name-of-branch-to-delete> (If you have trouble removing the remote branches, double-check your syntax is right, and make sure you use the --force flag.) the third case: a surgeon's nightmare If you have an absolute clusterf--k of a commit history, you need a gifted surgeon. The more gifted the surgeon, the more of your repo history you'll be able to retain. Here is a minimal-complications method that removes more of your history than you'd probably want. The method here is to leapfrog a whole series of complicated splits, merges, rebases, and other tangles, and jump directly to a point in the repo where things are saner and calmer. This is done by creating two commits (two repo states) that are exactly identical, and which can be used as the source and destination of a git rebase operation. To illustrate: suppose we have a tangled set of changes that all added or modified large files in the repository, and we wish to simply forget the whole thing ever happened. This method will leapfrog every commit between commit A and commit D. The Tangled Mess (Before): A B C D E (master) o-------o-------o-------o-------o---o---o \\ / / o---o---o---o / \\ \\ / o---o---o---o---o The Fixed Mess (After): D' E' (new_master) o----o / / (old history o is removed) A We start by adding one new commit D' to the clusterf--ked branch. This will compress all of the changes between A and D into a single commit. The state of the repository at D' should match precisely the state of the repository at commit D: D' ---------------------------------o / / B C D E A o-------o-------o-------o-------o---o---o \\ / / o---o---o---o / \\ \\ / o---o---o---o---o To do this, check out the repo commit where the clusterf--k is gone and when things are saner and calmer (that is, commit A): git checkout <commit-hash-for-A> Create a new branch at commit A, called new_master , git branch new_master git checkout new_master Now, add a commit at A that will bring the repository into the exact same state as the (clusterf--ked) branch (that is, commit D). To do this, copy every single file present in the folder at commit D, into the repository staging area for commit D'. You must copy every single file that is in that folder in commit D, excatly, word for word, character for character , into D'. If any files are in A but not in D, those files are extra and can be left alone without a problem. If any files are in D but not in A, you must add those files in when you create commit D'. Once your staged commit D' matches the staged commit D, commit your changes. Tag these two commits, D and D', as your \"stargates\" - commit D is your stargate source, and commit D' is your stargate destination. These commits are linked because the repository is in exactly the same state between commit D and commit D'. The last step is to rebase any commits that were made after the mess, that is, made after commit D, onto the new cleaner history. We do this using the syntax: git rebase --onto <new-head-base> <old-head-base> <branch-to-rebase> or, in terms of the stargate source and destination: git rebase --onto <stargate-dest> <stargate-src> <branch-to-rebase> or, in terms of commits D and D': git rebase --onto D' D E That allows you to take any commits made on D and rebase them onto D'. That way, you can throw away the messy part of the commit history but preserve all of the remaining commit history. Note that you will lose all information about commits that are not rebased or cherry picked, i.e., all the commits that were involved with the clusterf--k. The final state of the repo is: D' E' (new_master) o----o / / (old history o is removed) A Now delete the old master branch: git branch -D master git push origin :master --force Finally, push the new_master branch to the remote: git push origin new_master Pat yourself on the back - you've successfully unf--ked the repository.","title":"Oh F&!k: Please Send Backup"},{"location":"ohfk/#oh-fk-please-send-backup","text":"When you use the single-branch procedure instead of the multi-branch procedure... bad things happen. Possible complications to all of this include: Users who did not get the memo about the entire history of the repository being rewritten, who did not listen when they were told to clone a fresh copy, and who pushed directly to master even though they were told repeatedly not to, so then you end up with the entire old history being pushed to the remote. (Deal with this proactively by protecting the master branch!) Accidentally carrying out the procedure multiple times, resulting in 2, 3, 4, even 5 copies of each commit, and the duplicate commits simply refuse to die; A confusing, tangled, messy commit history that is completely uninterpretable","title":"Oh F&amp;!k: Please Send Backup"},{"location":"ohfk/#the-first-case-users-pushing-old-history","text":"When the git-commit-ectomy is complete, it is recommended that you turn on branch protection right away. But in case you did not, and a user pushed the old history to the remote, here is how to deal. From a copy of the repository with only the new history (this is going to be the copy of the repository that is on the surgeon's computer, preferrably the repo in which the git-commit-etomy was originally performed), run the command git push origin master --force (where origin is the remote with the duplicate history, and master is the name of the branch you're pushing. Replace these with whatever remote/branch names you are using.) Turn on branch protection immediately afterwards. If you do not have a copy of the repository with only the new history (i.e., if you removed the copy of the repository in which the git-commit-ectomy was performed), you can still separate the old and new histories. However, you must have a copy of the old git log and/or the new git log, so that you have some way of knowing which commits belong to which history. If you have this info, continue on to \"the second case.\"","title":"the first case: users pushing old history"},{"location":"ohfk/#the-second-case-scrubbling-multiple-attempts","text":"If you have performed a git-commit-ectomy multiple times, and the duplicate commits are simply piling up and will not go away, you will need to use either a git rebase or a git cherry pick operation. Find the branch that you want to keep, and the commit at which to start the new branch with the new history. Then rebase or cherry pick any missing commits onto it. Finally, remove all other branches on the remote. Example: Suppose we are trying to fix the history of the master branch, which is a mess, by creating a new branch new_master that has an improved and cleaned-up version of the master branch history. We start by checking out the particular commit where we wish new_master to diverge from master : git checkout <hash-of-commit-to-split-at> # starting point for new branch git branch new_master # create new branch git checkout new_master # switch to new branch Next, we modify the repository by making commits, doing git rebase and git cherry pick operations, and creating a new branch with a long and totally separate commit history from master. ...make some commits... ...rebase some stuff... ...cherry pick some stuff... ...now new branch has a long and totally different commit history from master... Finally, when the new_master branch is ready, push it to the remote (e.g., origin ): git push origin new_master # push all the new stuff to remote \"origin\" The last step is to delete all other branches except for the new_master branch, so that we don't preserve the messy history of the master branch. (The whole point of the new_master branch was to clean it up.) Deleting the master branch on the remote is a two step operation: first, delete the branch locally, then push the deleted \"ghost branch\" to the remote (which will propagate the deletion of the branch): git branch -D master # delete git branch master locally git push origin :master # propagate deletion of branch \"master\" to remote \"origin\" Note the syntax for deleting a branch is: git push <name-of-remote> :<name-of-branch-to-delete> (If you have trouble removing the remote branches, double-check your syntax is right, and make sure you use the --force flag.)","title":"the second case: scrubbling multiple attempts"},{"location":"ohfk/#the-third-case-a-surgeons-nightmare","text":"If you have an absolute clusterf--k of a commit history, you need a gifted surgeon. The more gifted the surgeon, the more of your repo history you'll be able to retain. Here is a minimal-complications method that removes more of your history than you'd probably want. The method here is to leapfrog a whole series of complicated splits, merges, rebases, and other tangles, and jump directly to a point in the repo where things are saner and calmer. This is done by creating two commits (two repo states) that are exactly identical, and which can be used as the source and destination of a git rebase operation. To illustrate: suppose we have a tangled set of changes that all added or modified large files in the repository, and we wish to simply forget the whole thing ever happened. This method will leapfrog every commit between commit A and commit D. The Tangled Mess (Before): A B C D E (master) o-------o-------o-------o-------o---o---o \\ / / o---o---o---o / \\ \\ / o---o---o---o---o The Fixed Mess (After): D' E' (new_master) o----o / / (old history o is removed) A We start by adding one new commit D' to the clusterf--ked branch. This will compress all of the changes between A and D into a single commit. The state of the repository at D' should match precisely the state of the repository at commit D: D' ---------------------------------o / / B C D E A o-------o-------o-------o-------o---o---o \\ / / o---o---o---o / \\ \\ / o---o---o---o---o To do this, check out the repo commit where the clusterf--k is gone and when things are saner and calmer (that is, commit A): git checkout <commit-hash-for-A> Create a new branch at commit A, called new_master , git branch new_master git checkout new_master Now, add a commit at A that will bring the repository into the exact same state as the (clusterf--ked) branch (that is, commit D). To do this, copy every single file present in the folder at commit D, into the repository staging area for commit D'. You must copy every single file that is in that folder in commit D, excatly, word for word, character for character , into D'. If any files are in A but not in D, those files are extra and can be left alone without a problem. If any files are in D but not in A, you must add those files in when you create commit D'. Once your staged commit D' matches the staged commit D, commit your changes. Tag these two commits, D and D', as your \"stargates\" - commit D is your stargate source, and commit D' is your stargate destination. These commits are linked because the repository is in exactly the same state between commit D and commit D'. The last step is to rebase any commits that were made after the mess, that is, made after commit D, onto the new cleaner history. We do this using the syntax: git rebase --onto <new-head-base> <old-head-base> <branch-to-rebase> or, in terms of the stargate source and destination: git rebase --onto <stargate-dest> <stargate-src> <branch-to-rebase> or, in terms of commits D and D': git rebase --onto D' D E That allows you to take any commits made on D and rebase them onto D'. That way, you can throw away the messy part of the commit history but preserve all of the remaining commit history. Note that you will lose all information about commits that are not rebased or cherry picked, i.e., all the commits that were involved with the clusterf--k. The final state of the repo is: D' E' (new_master) o----o / / (old history o is removed) A Now delete the old master branch: git branch -D master git push origin :master --force Finally, push the new_master branch to the remote: git push origin new_master Pat yourself on the back - you've successfully unf--ked the repository.","title":"the third case: a surgeon's nightmare"},{"location":"transplant/","text":"performing a transplant with patch if you are not able to save the branches as in the Multi-Branch Git-Commit-Ectomy Method , you can still save the changes that a particular set of commits made to a particular file or set of files using the patch utility together with git . creating patches with git git has the ability to create patches two ways. The first way is using git format-patch , which creates one patch per commit. This method preserves meta-information about the commit and is useful for transerring changes one commit at a time. The second way is using git diff --patch , which simply outputs the difference between the two commits, without any meta-information. We cover the latter method, since it is more general and can apply to ranges of commits. branch to branch Suppose you have some changes to the code that live in a separate branch, and you wish to save those changes for later (after the git-commit-ectomy is finished). For example: B master A o---o---o---o---o \\ \\ o---o---o---o C feature_branch To create a patch from the feature branch, it is best to run git diff to get the diff between the two branches, B and C, rather than the diff between the feature branch and the original commit, A and C. To produce the patch: git diff --patch feature_branch master > make_feature_branch.patch Note that this will not output diff information for binary files. To apply the patch, use the git am command (note, of all the git subcommand,s this subcommand has the absolute worst name imaginable ): git am < make_feature_branch.patch Alternatively, it is recommended that you keep the patch in cold storage, and only apply it to the master branch when the git commit ectomy is finished.","title":"Performing Transplants with Patch"},{"location":"transplant/#performing-a-transplant-with-patch","text":"if you are not able to save the branches as in the Multi-Branch Git-Commit-Ectomy Method , you can still save the changes that a particular set of commits made to a particular file or set of files using the patch utility together with git .","title":"performing a transplant with patch"},{"location":"transplant/#creating-patches-with-git","text":"git has the ability to create patches two ways. The first way is using git format-patch , which creates one patch per commit. This method preserves meta-information about the commit and is useful for transerring changes one commit at a time. The second way is using git diff --patch , which simply outputs the difference between the two commits, without any meta-information. We cover the latter method, since it is more general and can apply to ranges of commits.","title":"creating patches with git"},{"location":"transplant/#branch-to-branch","text":"Suppose you have some changes to the code that live in a separate branch, and you wish to save those changes for later (after the git-commit-ectomy is finished). For example: B master A o---o---o---o---o \\ \\ o---o---o---o C feature_branch To create a patch from the feature branch, it is best to run git diff to get the diff between the two branches, B and C, rather than the diff between the feature branch and the original commit, A and C. To produce the patch: git diff --patch feature_branch master > make_feature_branch.patch Note that this will not output diff information for binary files. To apply the patch, use the git am command (note, of all the git subcommand,s this subcommand has the absolute worst name imaginable ): git am < make_feature_branch.patch Alternatively, it is recommended that you keep the patch in cold storage, and only apply it to the master branch when the git commit ectomy is finished.","title":"branch to branch"}]}